# 前端开发学习笔记

[TOC]

## 1. HTML



## 2. CSS



## 3. JavaScript

### 3.1 类型与类型转换

#### 3.1.1 空值

- null：强调一个不存在的对象，其类型为对象object
- undefined：没有赋值过的变量，其值和类型都是undefined

#### 3.1.2 布尔值

- false值：false, 0, 空字符串, null, undefined, NaN

### 3.2 函数

#### 3.2.1 函数的表示

```javascript
function add(a,b){
	return a+b;
}
```

如果一个函数没有返回值，默认返回undefined

#### 3.2.1 函数的默认参数

```javascript
function add(a=0,b=0){
	return a+b;
}
```

该函数默认参数为0，即调用函数时如果没有传参，该函数默认设定参数为0（而不是原本的undefined）

另外，一个函数也可以作为另一个函数的参数

#### 3.2.2 函数的定义提升

函数本身是一个值，可以赋值给一个变量，然而赋值给变量时函数不会定义提升，必须在赋值后才可以调用。

如果直接使用`function add（）{}`这样的声明方式，那么函数会定义提升，可以在函数声明前就调用。

#### 3.2.3 箭头函数

如果函数只是一个表达式，可以把大括号和return省略，成为箭头函数

```js
const minus=(a,b)=>a-b
```

**将箭头函数作为参数**

```javascript
binaryOperator(2,5,(a,b)=>a*b)
```

**一个生成函数的函数**

```javascript
const buildRepeatChar=char=>{
    return num=>{
        let result='';
        while(num--){
            result+=char;
        }
        return result;
    }
}
```

生成的函数将参数char重复了参数num次

```javascript
const repeatDot=buildRepeatChar('.')//此时repeatDot时上面的函数buildRepeatChar生成的参数为num的函数
console.log(repeatDot(4))//输出结果是....
```

### 3.3 输出文件树

<img src="C:\Users\12061\AppData\Roaming\Typora\typora-user-images\image-20220712110507817.png" alt="image-20220712110507817" style="zoom:67%;" />

```javascript
let arr=['index.html',
         'js', 
         	['index.js'], 
         css, 
         	['index.css']
        ]
```

<img src="C:\Users\12061\AppData\Roaming\Typora\typora-user-images\image-20220712113652538.png" alt="image-20220712113652538" style="zoom: 67%;" />

### 3. HTML元素的操作

- `document.body.innerHTML=xxx`: 是指.body内部的HTML代码。将HTML页面的body标签中的内容替换为该语句等号后的内容

### 4. 异步编程

#### 4.1 回调函数

回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。

```javascript
function print() {
    document.getElementById("demo").innerHTML="RUNOOB!";
}
setTimeout(print, 3000);
```

这段程序中的 `setTimeout` 就是一个消耗时间较长（3 秒）的过程，它的第一个参数是个回调函数，第二个参数是毫秒数，这个函数执行之后会产生一个子线程，子线程会等待 3 秒，然后执行回调函数 `print`，在命令行输出 "RUNOOB!"。

#### 4.2 异步AJAX

XMLHttpRequest 常常用于请求来自远程服务器上的 XML 或 JSON 数据。一个标准的 XMLHttpRequest 对象往往包含多个回调：

```javascript
var xhr = new XMLHttpRequest();
 
xhr.onload = function () {
    // 输出接收到的文字数据
    document.getElementById("demo").innerHTML=xhr.responseText;
}
 
xhr.onerror = function () {
    document.getElementById("demo").innerHTML="请求出错";
}
 
// 发送异步 GET 请求
xhr.open("GET", "https://www.runoob.com/try/ajax/ajax_info.txt", true);
xhr.send();
```

XMLHttpRequest 的 onload 和 onerror 属性都是函数，分别在它请求成功和请求失败时被调用。如果你使用完整的 jQuery 库，也可以更加优雅的使用异步 AJAX：

```javascript
$.get("https://www.runoob.com/try/ajax/demo_test.php",function(data,status){
    alert("数据: " + data + "\n状态: " + status);
});
```

### 5. JavaScript Promise

Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。

#### 5.1 构造Promise

```javascript
new Promise(function (resolve, reject) {
    // 要做的事情...
});
```

Promise 构造函数只有一个参数，是一个函数，这个函数在构造之后会直接被异步运行，所以我们称之为起始函数。起始函数包含两个参数 `resolve` 和 `reject`。

#### 5.2 Promise的使用

`resolve` 和 `reject` 都是函数，其中调用 `resolve` 代表一切正常，`reject` 是出现异常时所调用的：

```javascript
new Promise(function (resolve, reject) {
    var a = 0;
    var b = 1;
    if (b == 0) reject("Divide zero");
    else resolve(a / b);
}).then(function (value) {
    console.log("a / b = " + value);
}).catch(function (err) {
    console.log(err);
}).finally(function () {
    console.log("End");
});
```

这段程序执行结果是:

```javascript
a / b = 0
End
```

Promise 类有 `.then()` `.catch()` 和 `.finally()` 三个方法，这三个方法的参数都是一个函数，`.then()` 可以将参数中的函数添加到当前 Promise 的正常执行序列，`.catch()` 则是设定 Promise 的异常处理序列，`.finally()` 是在 Promise 执行的最后一定会执行的序列。 `.then()` 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列：

```js
new Promise(function (resolve, reject) {
    console.log(1111);
    resolve(2222);
}).then(function (value) {
    console.log(value);
    return 3333;
}).then(function (value) {
    console.log(value);
    throw "An error";
}).catch(function (err) {
    console.log(err);
});
```

执行结果：

```js
1111
2222
3333
An error
```

`resolve()` 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作。

`reject()` 参数中一般会传递一个异常给之后的 `catch` 函数用于处理异常。

但是请注意以下两点：

- `resolve` 和 `reject` 的作用域只有起始函数，不包括 then 以及其他序列；
- `resolve` 和 `reject` 并不能够使起始函数停止运行，别忘了 `return`。

#### 5.3 Promise函数

```js
function print(delay, message) {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log(message);
            resolve();
        }, delay);
    });
}
```

```js
print(1000, "First").then(function () {
    return print(4000, "Second");
}).then(function () {
    print(3000, "Third");
});
```

这种返回值为一个 Promise 对象的函数称作 Promise 函数，它常常用于开发基于异步操作的库。

#### 5.4 异步函数

可以将上面的代码优化使用异步函数：

```js
async function asyncFunc() {
    await print(1000, "First");
    await print(4000, "Second");
    await print(3000, "Third");
}
asyncFunc();
```

异步函数 `async function` 中可以使用 `await` 指令，`await` 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。

异步函数实际上原理与 Promise 原生 API 的机制是一模一样的，只不过更便于程序员阅读。

如果 Promise 有一个正常的返回值，`await` 语句也会返回它：

```js
async function asyncFunc() {
    let value = await new Promise(
        function (resolve, reject) {
            resolve("Return value");
        }
    );
    console.log(value);
}
asyncFunc();
```

程序会输出:

```js
Return value
```

#### 5.5 注意事项

1. then 块默认会向下顺序执行，return 是不能中断的，可以通过 throw 来跳转至 catch 实现中断。
2. Promise适用情况：当需要多次顺序执行异步操作的时候，例如，如果想通过异步方法先后检测用户名和密码，需要先异步检测用户名，然后再异步检测密码的情况下就很适合 Promise。

### 6. JavaScript对象

对象只是一种特殊的数据。对象拥有**属性**和**方法**。

#### 6.1 访问对象的属性

```js
objectName.propertyName
```

#### 6.2 访问对象的方法

```js
objectName.methodName()
```

#### 6.3 对象构造器

```js
function person(firstname,lastname,age,eyecolor)
{
    this.firstname=firstname;
    this.lastname=lastname;
    this.age=age;
    this.eyecolor=eyecolor;
}
```

一旦有了对象构造器，就可以创建新的对象实例，就像这样：

```js
var myFather=new person("John","Doe",50,"blue");
var myMother=new person("Sally","Rally",48,"green");
```

#### 6.4 把方法添加到 JavaScript 对象

在构造器函数内部定义对象的方法：

```js
function person(firstname,lastname,age,eyecolor)
{
    this.firstname=firstname;
    this.lastname=lastname;
    this.age=age;
    this.eyecolor=eyecolor;

    this.changeName=changeName;
    function changeName(name)
    {
        this.lastname=name;
    }
}
```

#### 6.5 JavaScript for...in 循环

JavaScript for...in 语句循环遍历对象的**属性**。

```js
for (variable in object)
{
    //执行的代码……
}
```

 for...in 循环中的代码块将针对每个属性执行一次。

### 7. JavaScript prototype（原型对象）

#### 7.1 prototype继承

所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法：

- `Date` 对象从 `Date.prototype` 继承。
- `Array` 对象从 `Array.prototype` 继承。
- `Person` 对象从 `Person.prototype` 继承。

所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。

JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

`Date` 对象, `Array` 对象, 以及 `Person` 对象从 `Object.prototype` 继承。

#### 7.2 添加属性和方法

有的时候我们想要在所有已经存在的对象添加新的属性或方法。

另外，有时候我们想要在对象的构造函数中添加属性或方法。

使用 prototype 属性就可以给对象的构造函数添加新的属性：

```js
function Person(first, last, age, eyecolor) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eyecolor;
}
 
Person.prototype.nationality = "English";
```

当然我们也可以使用 prototype 属性就可以给对象的构造函数添加新的方法：

```js
function Person(first, last, age, eyecolor) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eyecolor;
}
 
Person.prototype.name = function() {
  return this.firstName + " " + this.lastName;
};
```

## 4. TypeScript

TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。

![image-20220712172400530](C:\Users\12061\AppData\Roaming\Typora\typora-user-images\image-20220712172400530.png)